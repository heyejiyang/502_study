# 자바보강

## 객체지향 프로그래밍1

### 1. 객체 지향 프로그래밍과 클래스
객체(Object)? 사물, 대상 

- 속성  : 정의, 상태  -> 변수(공간의 이름)
- **행위 :  -> 함수**

1) 객체와 객체지향 프로그래밍
2) 생활 속에서 객체 찾아보기
 - 객체 간의 협력 / **함수**를 통해서 이뤄진다.
	
> 👩‍🏫참고) SOLID 
	
### 2. 클래스 살펴보기

**클래스 -> 객체를 만들기 위한 설계 명세서**

1) 클래스를 정의하는 문법

```
class 클래스명 {
	변수 정의  // 멤버 변수 정의, 인스턴스 변수 정의 
	함수 정의  // 메서드 정의, 멤버 메서드 정의, 인스턴스 메서드 정의 
}
```

new 연산자 : 메모리에 생성을 담당하는 연산자
> 예) int[] nums = new int[3]; // 3개의 int 자료형 변수를 연속적으로 메모리 생성


`클래스명(자료형) 변수명 = new 클래스명();` 

> 👩‍🏫참고) 변수명 짓는 규칙 <br>1) 알파벳, 숫자, 특수문자($, _)<br>2) 숫자는 앞에 X<br>3) 예약어는 사용 불가(throw, if ...)<br>4) 관례 <br>
학생 수  : int noOfStudent;  : 낙타 표기법, 카멜표기법 <br>
상수:  final int MAX_OF_PERSON = 100;

2) 클래스 이름을 짓는 규칙<br>
	OrderInfo -> Order + Info // 파스칼표기법

3) 클래스의 속성을 구현하는 멤버변수
- 클래스에 변수 정의 -> 멤버 변수(정의)
- 클래스에 정의된 함수 -> 메서드

`변수.속성명`
`변수.함수명(....);`

### 3. 클래스와 인스턴스

인스턴스(instance) - 실체 : 실제로 존재한다.
- 생성된 객체 
(정의에 불과한 클래스 명세 -> 메모리에 생성된 객체(실체))

---
## 메서드
### 1. 함수란?
- 기능	
- 방정식 
예) 2x + 1 = y
	
### 2. 함수의 입력과 반환

### 3. 함수 정의하기
	
```
반환값 자료형  함수명 (매개변수 ....  ) {
// 실행될 코드 정의 
		
return 반환값;
}
```

1) 함수이름
2) 매개변수
3) return 예약어와 반환형

### 4. 함수 호출하고 값 반환하기
호출 -> `함수명(값, ...);` 
	
### 5. 매개변수 살펴보기
### 6. 함수 호출과 스택 메모리
스택 메모리 : 임시메모리 
-> 함수가 연산을 수행할때만 공간을 할당, 작업 완료(return) -> 제거
	
👩‍🏫참고)
스택(stack) 구조 
- 가장 마지막에 투입된 자료 : 가장 먼저 나오고
- 가장 처음에 투입된 자료 : 가장 나중에 나온다.
			
큐(queue) 구조

-  함수에 정의된 변수 -> 스택에서 활성화, 스택에서 제거 
- 함수 지역 -> 지역 변수 
	
### 7. 함수의 장점
### 8. 클래스 기능을 구현하는 메서드

힙 영역 메모리 : 객체 전용 메모리

- **참조 자료형**<br>
클래스 형태의 자료형 -> 객체가 되어야 사용 가능 
	
**참조 변수 : 생성된 객체의 주소값을 가지고 있는 변수**


👩‍🏫참고)<br>
**기본 자료형 : 재료가 되는 자료형**
: 숫자를 표현할 수 있는 자료형
	
- 정수
  - byte(1)
  - short(2)
  - int(4)
  - long(8)
		
- 실수
  - float(4)
  - double(8)
		
- 문자형
  유니코드(2~3)
    - 문자를 숫자로 매칭 표, 아스키코드(1)
    - char(2~3) 
		
- 논리형
boolean(1)

**참조 자료형**
- 기본 자료형을 제외한 모든 자료형
- 자원을 접근할 수 있는 주소값만 가지는 자료형

---
## 생성자
- 클래스명과 동일한 명칭의 함수 
- 객체를 생성해 주는 역할 
- 반환값이 객체의 주소값이므로 반환값 정의 X (return 예약어 사용 불가)

*데이터 영역 메모리(코드 & 상수 영역 메모리)
![image](https://github.com/heyejiyang/502_study/assets/132132524/ac679833-f613-499c-a17b-799cc61a870b)

- 클래스 로더 -> 클래스 파일 -> 데이터 영역 로드 <br>
-> **Class 클래스** 객체 생성 (🎀클래스에 대한 정보성 객체🎀)

  - 모든 클래스에스는 class 정적 변수 존재 : Class 클래스 객체
 
### 1. 디폴트 생성자(기본 생성자)
- 클래스에 생성자 메서드가 정의된 것이 없으면 -> 컴파일러가 자동 추가
`public 클래스명() {}`		
		
### 2. 생성자 만들기
### 3. 생성자 오버로드

👩‍🏫참고)<br>
함수(메서드)를 구분하는 명칭의 기준(함수의 시그니쳐)<br>
패키명.클래스명  + 반환값 타입 + 함수명 + 매개변수 정의 + 예외 전가 : 함수의 시그니쳐<br>
-> 함수의 시그니쳐가 다르면?? ---> 다른 함수 
	
> 함수명이 동일하지만 함수의 시그니쳐를 다르게 정의해서 여러개를 정의하는 방식 : 메서드 오버로드💫

---
## 정보 은닉
- 통제
- 멤버 변수에 직접 값을 대입하는 것 -> 통제 불가 => 사용 XX (멤버 변수의 접근 제어자(private))
- 멤버 변수의 값을 확인할 수 있는 접근 가능한 메서드 추가

### 1. 접근제어자 정리
🔖public : 다른 패키지에서도 접근이 가능 <br>
👩‍🏫참고)
다른 패키지에 있는 클래스를 사용하려면 import
`import 패키지명.클래스명;`<br>
🔖protected : 동일 패키지에서 접근 가능(default) + **외부 패키지에 있는 클래스에서 상속을 받으면 클래스 내부에서 접근 가능(private)**<br
🔖default : 접근 제어자를 명시 X  : 동일 패키지에서 접근 가능<br>
🔖private : 클래스 내부에서만 접근 가능

		
### 2. get(), set() 메서드

get - 값 조회
set - 값 설정

### this 예약어		 
- 지역변수 : **현재 생성된 객체의 주소값, 참조 변수** <br>
: 📚 **객체의 자원(인스턴스 변수, 인스턴스 메서드)을 인스턴스 메서드 내부에서 접근하기위한 목적**
				
- 메서드 : `this(...)`  - 현재 생성된 객체의 생성자 메서드를 의미 

## 변수의 유효범위

### 1. 지역변수 
- 함수가 실행될때 공간 할당
- 함수가 수행을 종료하면 공간 해제
- 함수 지역 안에서만 유효한 변수
- 스택에서 공간 할당

### 2. 멤버변수(인스턴스 변수)
- 객체가 생성될때 공간 할당
- 힙에서 공간 할당
- 참조가 더이상 없으면(즉, 더이상 사용을 하지않으면) 가비지 콜렉터가 제거한다.

### 3. static 변수 
- static : 정적인
- 처음부터 정적인 메모리에 공간을 할당
- 데이터 영역에서 메모리 할당
- 객체 생성과 상관없이 처음부터 사용 가능
- 애플리케이션 종료되면 제거
	
👩‍🏫참고)<br>
정적 메모리- 데이터<br>		
동적 메모리- 스택, 힙

- 정적인 방법으로 직접 접근 권장(클래스명.변수명)
- 클래스 변수라고 한다!
- 🌟**객체 생성과 관련 없이 처음부터 쓸 수 있는 변수**

- static 메서드: 정적 메서드 - 객체 생성과 상관없이 정적인 방법으로 호출 가능
    - 클래스명.메서드명()
    - 클래스 메서드
    - 🌟this가 존재하지 않음, this사용불가

static 응용 - 싱글톤 패턴
: 기본 자료형을 제외한 모든 자료형
: 자원을 접근할 수 있는 주소값만 가지는 자료형
		
`==` : 주소 비교(자원 주소)

---
## 객체지향 프로그래밍2
### 상속

1. 상속이란?
부모클래스 자식이 상속<br>
상위클래스에 정의된 내용을 하위클래스가 객체가 되면 사용가능해진다.

3. 클래스의 상속
- 하위클래스가 상위클래스를 상속받는 이유❔

  - 생성자에는 정의하지 않아도 첫번째 줄에 컴파일러가 `super();`을 생성해 준다.<br> 이 super메서드는 자동으로 상위클래스의 기본 생성자 메서드를 호출하기 때문에 extends를 해주면 자동적으로 상위클래스를 상속하게 된다.
    
4. 클래스 상속 문법
```   
   class 하위클래스 extends 상위 클래스{
}
```
4. super
- 생성자의 첫번째 라인에 따로 정의하지 않아도 무조건 추가되어있다(상속받았을경우)
- 지역변수일때: 상위 클래스 객체의 주소값(참조변수)
- 함수일때(super()): 상위 클래스의 생성자 메서드

상위클래스 : 일반적인 개념 

하위클래스 : 구체적인 개념

>참고) this: 지역변수 - 현재 객체의 주소값(참조변수)<br>
	: 함수(this() - 현재 클래스에 정의된 생성자 함수를 호출


### 메서드 재정의
1. 메소드 재정의 	
	- 상의클래스의 메서드명과 동일한 메서드 
	
2. 묵시적 형변환과 메서드 재정의
3. 가상메서드

### 다형성  
![image](https://github.com/heyejiyang/502_study/assets/132132524/10c50579-5164-4b2b-a389-855810e9322a)

![image](https://github.com/heyejiyang/502_study/assets/132132524/d46a15ca-6dec-4b44-a59d-7e1be40ec28a)

![image](https://github.com/heyejiyang/502_study/assets/132132524/77442f98-e48d-461b-8600-a5e94291f12d)

1. 다운 캐스팅과 instanceof
   instanceof: 객체의 출처를 체크하는 연산자
   
   ![image](https://github.com/heyejiyang/502_study/assets/132132524/782ffc7e-5406-4ecc-91f5-ad0526572043)

